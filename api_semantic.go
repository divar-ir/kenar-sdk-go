/*
API کنار

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package kenarapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// SemanticAPIService SemanticAPI service
type SemanticAPIService service

type ApiSemanticCreatePostSemanticRequest struct {
	ctx context.Context
	ApiService *SemanticAPIService
	token string
	semanticCreatePostSemanticBody *SemanticCreatePostSemanticBody
}

func (r ApiSemanticCreatePostSemanticRequest) SemanticCreatePostSemanticBody(semanticCreatePostSemanticBody SemanticCreatePostSemanticBody) ApiSemanticCreatePostSemanticRequest {
	r.semanticCreatePostSemanticBody = &semanticCreatePostSemanticBody
	return r
}

func (r ApiSemanticCreatePostSemanticRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SemanticCreatePostSemanticExecute(r)
}

/*
SemanticCreatePostSemantic ایجاد اطلاعات معنایی آگهی

در برخی موارد، ذخیره اطلاعات مربوط به آگهی در دیوار بدون افزودن افزونه ضروری است.
این API توکن دسترسی با دامنه `POST_SEMANTIC_CREATE` را انتظار دارد.


مجوزهای مورد نیاز: POST_SEMANTIC_CREATE.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token
 @return ApiSemanticCreatePostSemanticRequest
*/
func (a *SemanticAPIService) SemanticCreatePostSemantic(ctx context.Context, token string) ApiSemanticCreatePostSemanticRequest {
	return ApiSemanticCreatePostSemanticRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *SemanticAPIService) SemanticCreatePostSemanticExecute(r ApiSemanticCreatePostSemanticRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SemanticAPIService.SemanticCreatePostSemantic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/experimental/open-platform/semantic/post/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.semanticCreatePostSemanticBody == nil {
		return localVarReturnValue, nil, reportError("semanticCreatePostSemanticBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.semanticCreatePostSemanticBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSemanticCreateUserSemanticRequest struct {
	ctx context.Context
	ApiService *SemanticAPIService
	phone string
	semanticCreateUserSemanticBody *SemanticCreateUserSemanticBody
}

func (r ApiSemanticCreateUserSemanticRequest) SemanticCreateUserSemanticBody(semanticCreateUserSemanticBody SemanticCreateUserSemanticBody) ApiSemanticCreateUserSemanticRequest {
	r.semanticCreateUserSemanticBody = &semanticCreateUserSemanticBody
	return r
}

func (r ApiSemanticCreateUserSemanticRequest) Execute() (*SemanticCreateUserSemanticResponse, *http.Response, error) {
	return r.ApiService.SemanticCreateUserSemanticExecute(r)
}

/*
SemanticCreateUserSemantic ایجاد اطلاعات معنایی کاربر

در برخی موارد، ذخیره اطلاعات مربوط به کاربر در دیوار بدون افزودن افزونه ضروری است.
نام کاربری در دیوار همان شماره موبایل است.
این API توکن دسترسی با دامنه `USER_VERIFICATION_CREATE` را انتظار دارد.
از APIهای اطلاعات معنایی کاربر برای این منظور استفاده کنید. این سرویس امکان ارسال اطلاعات معنایی و بلیط پرداخت اختیاری را فراهم می‌کند.

مجوزهای مورد نیاز: USER_SEMANTIC_CREATE.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param phone
 @return ApiSemanticCreateUserSemanticRequest
*/
func (a *SemanticAPIService) SemanticCreateUserSemantic(ctx context.Context, phone string) ApiSemanticCreateUserSemanticRequest {
	return ApiSemanticCreateUserSemanticRequest{
		ApiService: a,
		ctx: ctx,
		phone: phone,
	}
}

// Execute executes the request
//  @return SemanticCreateUserSemanticResponse
func (a *SemanticAPIService) SemanticCreateUserSemanticExecute(r ApiSemanticCreateUserSemanticRequest) (*SemanticCreateUserSemanticResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SemanticCreateUserSemanticResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SemanticAPIService.SemanticCreateUserSemantic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/open-platform/semantic/user/{phone}"
	localVarPath = strings.Replace(localVarPath, "{"+"phone"+"}", url.PathEscape(parameterValueToString(r.phone, "phone")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.semanticCreateUserSemanticBody == nil {
		return localVarReturnValue, nil, reportError("semanticCreateUserSemanticBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.semanticCreateUserSemanticBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSemanticCreateUserSemantic2Request struct {
	ctx context.Context
	ApiService *SemanticAPIService
	divarUserId string
	semanticCreateUserSemanticBody *SemanticCreateUserSemanticBody
}

func (r ApiSemanticCreateUserSemantic2Request) SemanticCreateUserSemanticBody(semanticCreateUserSemanticBody SemanticCreateUserSemanticBody) ApiSemanticCreateUserSemantic2Request {
	r.semanticCreateUserSemanticBody = &semanticCreateUserSemanticBody
	return r
}

func (r ApiSemanticCreateUserSemantic2Request) Execute() (*SemanticCreateUserSemanticResponse, *http.Response, error) {
	return r.ApiService.SemanticCreateUserSemantic2Execute(r)
}

/*
SemanticCreateUserSemantic2 ایجاد اطلاعات معنایی کاربر

در برخی موارد، ذخیره اطلاعات مربوط به کاربر در دیوار بدون افزودن افزونه ضروری است.
نام کاربری در دیوار همان شماره موبایل است.
این API توکن دسترسی با دامنه `USER_VERIFICATION_CREATE` را انتظار دارد.
از APIهای اطلاعات معنایی کاربر برای این منظور استفاده کنید. این سرویس امکان ارسال اطلاعات معنایی و بلیط پرداخت اختیاری را فراهم می‌کند.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param divarUserId
 @return ApiSemanticCreateUserSemantic2Request
*/
func (a *SemanticAPIService) SemanticCreateUserSemantic2(ctx context.Context, divarUserId string) ApiSemanticCreateUserSemantic2Request {
	return ApiSemanticCreateUserSemantic2Request{
		ApiService: a,
		ctx: ctx,
		divarUserId: divarUserId,
	}
}

// Execute executes the request
//  @return SemanticCreateUserSemanticResponse
func (a *SemanticAPIService) SemanticCreateUserSemantic2Execute(r ApiSemanticCreateUserSemantic2Request) (*SemanticCreateUserSemanticResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SemanticCreateUserSemanticResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SemanticAPIService.SemanticCreateUserSemantic2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/open-platform/semantic/users/{divar_user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"divar_user_id"+"}", url.PathEscape(parameterValueToString(r.divarUserId, "divarUserId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.semanticCreateUserSemanticBody == nil {
		return localVarReturnValue, nil, reportError("semanticCreateUserSemanticBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.semanticCreateUserSemanticBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSemanticDeleteUserSemanticRequest struct {
	ctx context.Context
	ApiService *SemanticAPIService
	phone string
	divarUserId *string
}

func (r ApiSemanticDeleteUserSemanticRequest) DivarUserId(divarUserId string) ApiSemanticDeleteUserSemanticRequest {
	r.divarUserId = &divarUserId
	return r
}

func (r ApiSemanticDeleteUserSemanticRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SemanticDeleteUserSemanticExecute(r)
}

/*
SemanticDeleteUserSemantic حذف اطلاعات معنایی کاربر

می‌توانید اطلاعات معنایی یک کاربر را با فراخوانی این API حذف کنید.

مجوزهای مورد نیاز: USER_SEMANTIC_DELETE.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param phone
 @return ApiSemanticDeleteUserSemanticRequest
*/
func (a *SemanticAPIService) SemanticDeleteUserSemantic(ctx context.Context, phone string) ApiSemanticDeleteUserSemanticRequest {
	return ApiSemanticDeleteUserSemanticRequest{
		ApiService: a,
		ctx: ctx,
		phone: phone,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *SemanticAPIService) SemanticDeleteUserSemanticExecute(r ApiSemanticDeleteUserSemanticRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SemanticAPIService.SemanticDeleteUserSemantic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/open-platform/semantic/user/{phone}"
	localVarPath = strings.Replace(localVarPath, "{"+"phone"+"}", url.PathEscape(parameterValueToString(r.phone, "phone")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.divarUserId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "divar_user_id", r.divarUserId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSemanticDeleteUserSemantic2Request struct {
	ctx context.Context
	ApiService *SemanticAPIService
	divarUserId string
	phone *string
}

func (r ApiSemanticDeleteUserSemantic2Request) Phone(phone string) ApiSemanticDeleteUserSemantic2Request {
	r.phone = &phone
	return r
}

func (r ApiSemanticDeleteUserSemantic2Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SemanticDeleteUserSemantic2Execute(r)
}

/*
SemanticDeleteUserSemantic2 حذف اطلاعات معنایی کاربر

می‌توانید اطلاعات معنایی یک کاربر را با فراخوانی این API حذف کنید.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param divarUserId
 @return ApiSemanticDeleteUserSemantic2Request
*/
func (a *SemanticAPIService) SemanticDeleteUserSemantic2(ctx context.Context, divarUserId string) ApiSemanticDeleteUserSemantic2Request {
	return ApiSemanticDeleteUserSemantic2Request{
		ApiService: a,
		ctx: ctx,
		divarUserId: divarUserId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *SemanticAPIService) SemanticDeleteUserSemantic2Execute(r ApiSemanticDeleteUserSemantic2Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SemanticAPIService.SemanticDeleteUserSemantic2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/open-platform/semantic/users/{divar_user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"divar_user_id"+"}", url.PathEscape(parameterValueToString(r.divarUserId, "divarUserId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.phone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "phone", r.phone, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
