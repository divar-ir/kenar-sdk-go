/*
divar_interface/open_platform/chatapi/chatapi.proto

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: version not set
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package kenarapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// EventsAPIService EventsAPI service
type EventsAPIService service

type ApiEventsRegisterEventSubscriptionRequest struct {
	ctx context.Context
	ApiService *EventsAPIService
	eventsRegisterEventSubscriptionRequest *EventsRegisterEventSubscriptionRequest
}

func (r ApiEventsRegisterEventSubscriptionRequest) EventsRegisterEventSubscriptionRequest(eventsRegisterEventSubscriptionRequest EventsRegisterEventSubscriptionRequest) ApiEventsRegisterEventSubscriptionRequest {
	r.eventsRegisterEventSubscriptionRequest = &eventsRegisterEventSubscriptionRequest
	return r
}

func (r ApiEventsRegisterEventSubscriptionRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.EventsRegisterEventSubscriptionExecute(r)
}

/*
EventsRegisterEventSubscription Subscribe to an event

This requests allows you to subscribe to an event.
You need to send access-token in this API to check your access.
For subscribing on `NEW_MESSAGE_ON_POST` you need one of these scopes:
- CHAT_POST_CONVERSATIONS_READ.{post_token}
- CHAT_SUPPLIER_ALL_CONVERSATIONS_READ
For subscribing on `POST_UPDATE` you need `USER_POSTS_GET` scope.
After calling this API, You'll be notified in your webhook when corresponding event occurs.
Make sure webhook URL is set on providers panel for your app.
Some events are enabled by default and no subscription is needed for them(e.g chatbot messages).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEventsRegisterEventSubscriptionRequest
*/
func (a *EventsAPIService) EventsRegisterEventSubscription(ctx context.Context) ApiEventsRegisterEventSubscriptionRequest {
	return ApiEventsRegisterEventSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *EventsAPIService) EventsRegisterEventSubscriptionExecute(r ApiEventsRegisterEventSubscriptionRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventsAPIService.EventsRegisterEventSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/open-platform/events/subscriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.eventsRegisterEventSubscriptionRequest == nil {
		return localVarReturnValue, nil, reportError("eventsRegisterEventSubscriptionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.eventsRegisterEventSubscriptionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
