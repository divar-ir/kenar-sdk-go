/*
API کنار

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package kenarapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// PaymentAPIService PaymentAPI service
type PaymentAPIService service

type ApiPaymentCommitWalletTransactionRequest struct {
	ctx context.Context
	ApiService *PaymentAPIService
	paymentCommitWalletTransactionRequest *PaymentCommitWalletTransactionRequest
}

func (r ApiPaymentCommitWalletTransactionRequest) PaymentCommitWalletTransactionRequest(paymentCommitWalletTransactionRequest PaymentCommitWalletTransactionRequest) ApiPaymentCommitWalletTransactionRequest {
	r.paymentCommitWalletTransactionRequest = &paymentCommitWalletTransactionRequest
	return r
}

func (r ApiPaymentCommitWalletTransactionRequest) Execute() (*PaymentCommitWalletTransactionResponse, *http.Response, error) {
	return r.ApiService.PaymentCommitWalletTransactionExecute(r)
}

/*
PaymentCommitWalletTransaction نهایی کردن تراکنش کیف پول

این API تراکنش پرداخت کیف پول را پس از پرداخت موفق نهایی می‌کند.

**نکات مهم**:
- این قابلیت آزمایشی است و فقط برای اپلیکیشن‌های تایید شده در دسترس است
- فقط تراکنش‌هایی که در وضعیت PAID هستند را نهایی کنید

#### دسترسی‌ها:

##### مجوزهای API Key مورد نیاز:

- `WALLET_PAYMENT`

##### OAuth اسکوپ موردنیاز:

- `CREATE_WALLET_PAYMENT`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPaymentCommitWalletTransactionRequest
*/
func (a *PaymentAPIService) PaymentCommitWalletTransaction(ctx context.Context) ApiPaymentCommitWalletTransactionRequest {
	return ApiPaymentCommitWalletTransactionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaymentCommitWalletTransactionResponse
func (a *PaymentAPIService) PaymentCommitWalletTransactionExecute(r ApiPaymentCommitWalletTransactionRequest) (*PaymentCommitWalletTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentCommitWalletTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentAPIService.PaymentCommitWalletTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/experimental/open-platform/wallet/payments/commit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.paymentCommitWalletTransactionRequest == nil {
		return localVarReturnValue, nil, reportError("paymentCommitWalletTransactionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.paymentCommitWalletTransactionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPaymentCreateWalletPaymentRequest struct {
	ctx context.Context
	ApiService *PaymentAPIService
	paymentCreateWalletPaymentRequest *PaymentCreateWalletPaymentRequest
}

func (r ApiPaymentCreateWalletPaymentRequest) PaymentCreateWalletPaymentRequest(paymentCreateWalletPaymentRequest PaymentCreateWalletPaymentRequest) ApiPaymentCreateWalletPaymentRequest {
	r.paymentCreateWalletPaymentRequest = &paymentCreateWalletPaymentRequest
	return r
}

func (r ApiPaymentCreateWalletPaymentRequest) Execute() (*PaymentCreateWalletPaymentResponse, *http.Response, error) {
	return r.ApiService.PaymentCreateWalletPaymentExecute(r)
}

/*
PaymentCreateWalletPayment ایجاد پرداخت کیف پول

این API امکان شروع تراکنش پرداخت از کیف پول دیوار کاربر را فراهم می‌کند. کاربر برای تکمیل پرداخت هدایت می‌شود و می‌توانید وضعیت تراکنش را پیگیری کنید.

**نکات مهم**:
- این قابلیت آزمایشی است و فقط برای اپلیکیشن‌های تایید شده در دسترس است
- کاربر برای تکمیل تراکنش به آدرس پرداخت هدایت می‌شود
- پس از پرداخت، کاربر به `redirect_url` مشخص شده شما هدایت می‌شود
- از `RetrieveWalletTransaction` برای بررسی وضعیت پرداخت استفاده کنید
- از `CommitWalletTransaction` برای نهایی کردن تراکنش پس از پرداخت موفق استفاده کنید


#### دسترسی‌ها:

##### مجوزهای API Key مورد نیاز:

- `WALLET_PAYMENT`

##### OAuth اسکوپ موردنیاز:

- `CREATE_WALLET_PAYMENT`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPaymentCreateWalletPaymentRequest
*/
func (a *PaymentAPIService) PaymentCreateWalletPayment(ctx context.Context) ApiPaymentCreateWalletPaymentRequest {
	return ApiPaymentCreateWalletPaymentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaymentCreateWalletPaymentResponse
func (a *PaymentAPIService) PaymentCreateWalletPaymentExecute(r ApiPaymentCreateWalletPaymentRequest) (*PaymentCreateWalletPaymentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentCreateWalletPaymentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentAPIService.PaymentCreateWalletPayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/experimental/open-platform/wallet/payments/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.paymentCreateWalletPaymentRequest == nil {
		return localVarReturnValue, nil, reportError("paymentCreateWalletPaymentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.paymentCreateWalletPaymentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPaymentGetBalanceRequest struct {
	ctx context.Context
	ApiService *PaymentAPIService
}

func (r ApiPaymentGetBalanceRequest) Execute() (*PaymentGetBalanceResponse, *http.Response, error) {
	return r.ApiService.PaymentGetBalanceExecute(r)
}

/*
PaymentGetBalance دریافت موجودی اپلیکیشن

این API امکان دریافت موجودی فعلی اپلیکیشن شما به ریال را فراهم می‌کند. برای نظارت بر موجودی حساب قبل از انجام عملیات‌های پولی استفاده کنید.

**نکات مهم**:
- این قابلیت فقط برای اپلیکیشن‌های تایید شده در دسترس است
- موجودی به ریال ایران برگردانده می‌شود

#### دسترسی‌ها:

##### مجوزهای API Key مورد نیاز:

- `BALANCE_RETRIEVE`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPaymentGetBalanceRequest
*/
func (a *PaymentAPIService) PaymentGetBalance(ctx context.Context) ApiPaymentGetBalanceRequest {
	return ApiPaymentGetBalanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaymentGetBalanceResponse
func (a *PaymentAPIService) PaymentGetBalanceExecute(r ApiPaymentGetBalanceRequest) (*PaymentGetBalanceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentGetBalanceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentAPIService.PaymentGetBalance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/experimental/open-platform/balance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPaymentGetPostPricingRequest struct {
	ctx context.Context
	ApiService *PaymentAPIService
	postToken string
}

func (r ApiPaymentGetPostPricingRequest) Execute() (*PaymentGetPostPricingResponse, *http.Response, error) {
	return r.ApiService.PaymentGetPostPricingExecute(r)
}

/*
PaymentGetPostPricing دریافت قیمت خدمات آگهی

این API امکان دریافت اطلاعات قیمت‌گذاری برای خدمات مرتبط با آگهی را فراهم می‌کند. قبل از انجام عملیات‌های پولی مانند نردبان، تمدید یا ثبت آگهی از این برای بررسی هزینه‌ها استفاده کنید.

**نکات مهم**:
- قیمت‌گذاری مختص اپلیکیشن شما است و ممکن است با قیمت‌گذاری استاندارد دیوار متفاوت باشد
- قیمت‌ها ممکن است بر اساس دسته‌بندی و شهر آگهی متفاوت باشند
- فلگ `available` نشان می‌دهد که آیا سرویس برای این آگهی قابل اعمال است

#### دسترسی‌ها:

##### مجوزهای API Key مورد نیاز:

- `POST_PRICING_RETRIEVE`

##### OAuth اسکوپ موردنیاز:

- `PAYMENT_ALL_POSTS_PRICING_READ`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param postToken شناسه منحصر به فرد 8-9 کاراکتری برای آگهی
 @return ApiPaymentGetPostPricingRequest
*/
func (a *PaymentAPIService) PaymentGetPostPricing(ctx context.Context, postToken string) ApiPaymentGetPostPricingRequest {
	return ApiPaymentGetPostPricingRequest{
		ApiService: a,
		ctx: ctx,
		postToken: postToken,
	}
}

// Execute executes the request
//  @return PaymentGetPostPricingResponse
func (a *PaymentAPIService) PaymentGetPostPricingExecute(r ApiPaymentGetPostPricingRequest) (*PaymentGetPostPricingResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentGetPostPricingResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentAPIService.PaymentGetPostPricing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/open-platform/post/{post_token}/pricing"
	localVarPath = strings.Replace(localVarPath, "{"+"post_token"+"}", url.PathEscape(parameterValueToString(r.postToken, "postToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPaymentGetTransactionRequest struct {
	ctx context.Context
	ApiService *PaymentAPIService
	id string
}

func (r ApiPaymentGetTransactionRequest) Execute() (*PaymentGetTransactionResponse, *http.Response, error) {
	return r.ApiService.PaymentGetTransactionExecute(r)
}

/*
PaymentGetTransaction دریافت جزئیات تراکنش

این API امکان دریافت اطلاعات دقیق یک تراکنش خاص با شناسه آن را فراهم می‌کند. برای پیگیری وضعیت تراکنش، هزینه‌ها و متادیتا استفاده کنید.

**نکات مهم**:
- این قابلیت فقط برای اپلیکیشن‌های تایید شده در دسترس است
- شناسه تراکنش همان UUID است که هنگام ایجاد تراکنش ارسال کردید
- وضعیت‌های تراکنش: PENDING، COMPLETED، FAILED، REFUNDED
- انواع تراکنش: REORDER، SUBMIT، RENEW
- برای تایید تکمیل تراکنش پس از عملیات‌های پولی استفاده کنید

#### دسترسی‌ها:

##### مجوزهای API Key مورد نیاز:

- `TRANSACTION_RETRIEVE`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id شناسه منحصر به فرد برای تراکنش، همان id در درخواست
 @return ApiPaymentGetTransactionRequest
*/
func (a *PaymentAPIService) PaymentGetTransaction(ctx context.Context, id string) ApiPaymentGetTransactionRequest {
	return ApiPaymentGetTransactionRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaymentGetTransactionResponse
func (a *PaymentAPIService) PaymentGetTransactionExecute(r ApiPaymentGetTransactionRequest) (*PaymentGetTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentGetTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentAPIService.PaymentGetTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/experimental/open-platform/transactions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPaymentListTransactionsRequest struct {
	ctx context.Context
	ApiService *PaymentAPIService
	pageSize *int32
	pageToken *string
}

// تعداد تراکنش‌ها در هر صفحه
func (r ApiPaymentListTransactionsRequest) PageSize(pageSize int32) ApiPaymentListTransactionsRequest {
	r.pageSize = &pageSize
	return r
}

// توکن برای صفحه بعدی نتایج
func (r ApiPaymentListTransactionsRequest) PageToken(pageToken string) ApiPaymentListTransactionsRequest {
	r.pageToken = &pageToken
	return r
}

func (r ApiPaymentListTransactionsRequest) Execute() (*PaymentListTransactionsResponse, *http.Response, error) {
	return r.ApiService.PaymentListTransactionsExecute(r)
}

/*
PaymentListTransactions لیست تراکنش‌ها

این API امکان دریافت لیست صفحه‌بندی شده از تراکنش‌های اپلیکیشن شما را فراهم می‌کند. برای تاریخچه تراکنش، ممیزی و تسویه حساب استفاده کنید.

**نکات مهم**:
- این قابلیت فقط برای اپلیکیشن‌های تایید شده در دسترس است
- نتایج صفحه‌بندی شده هستند - از `page_size` برای کنترل تعداد آیتم‌ها در هر صفحه استفاده کنید
- از `page_token` در پاسخ برای دریافت صفحه بعدی استفاده کنید
- تراکنش‌ها بر اساس زمان ایجاد مرتب می‌شوند (جدیدترین اول)

#### دسترسی‌ها:

##### مجوزهای API Key مورد نیاز:

- `TRANSACTION_LIST`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPaymentListTransactionsRequest
*/
func (a *PaymentAPIService) PaymentListTransactions(ctx context.Context) ApiPaymentListTransactionsRequest {
	return ApiPaymentListTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaymentListTransactionsResponse
func (a *PaymentAPIService) PaymentListTransactionsExecute(r ApiPaymentListTransactionsRequest) (*PaymentListTransactionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentListTransactionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentAPIService.PaymentListTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/experimental/open-platform/transactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.pageToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_token", r.pageToken, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPaymentPublishUserPostRequest struct {
	ctx context.Context
	ApiService *PaymentAPIService
	postToken string
	paymentPublishUserPostBody *PaymentPublishUserPostBody
}

func (r ApiPaymentPublishUserPostRequest) PaymentPublishUserPostBody(paymentPublishUserPostBody PaymentPublishUserPostBody) ApiPaymentPublishUserPostRequest {
	r.paymentPublishUserPostBody = &paymentPublishUserPostBody
	return r
}

func (r ApiPaymentPublishUserPostRequest) Execute() (*PaymentPublishUserPostResponse, *http.Response, error) {
	return r.ApiService.PaymentPublishUserPostExecute(r)
}

/*
PaymentPublishUserPost انتشار آگهی کاربر (پرداخت توسط ارائه‌دهنده)

این API امکان پرداخت هزینه انتشار آگهی ثبت شده توسط کاربر از طرف اپلیکیشن شما را فراهم می‌کند. هزینه از موجودی اپلیکیشن شما کسر می‌شود و آگهی منتشر می‌شود.

**نکات مهم**:
- ابتدا آگهی باید با API `SubmitUserPost` ایجاد شده باشد
- یک `id` منحصر به فرد (UUID v4) برای جلوگیری از تکرار ارسال کنید
- آگهی باید در وضعیت نیازمند پرداخت (WAITING_FOR_PAYMENT) باشد
- از کافی بودن موجودی اپلیکیشن خود اطمینان حاصل کنید
- هزینه‌ها بر اساس دسته‌بندی و شهر آگهی متفاوت است

#### دسترسی‌ها:

##### مجوزهای API Key مورد نیاز:

- `PUBLISH_USER_POST`

##### OAuth اسکوپ موردنیاز:

- `SUBMIT_USER_POST`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param postToken توکن آگهی دریافت شده از RPC SubmitUserPost. شناسه منحصر به فرد 8-9 کاراکتری برای آگهی ثبت شده توسط کاربر.
 @return ApiPaymentPublishUserPostRequest
*/
func (a *PaymentAPIService) PaymentPublishUserPost(ctx context.Context, postToken string) ApiPaymentPublishUserPostRequest {
	return ApiPaymentPublishUserPostRequest{
		ApiService: a,
		ctx: ctx,
		postToken: postToken,
	}
}

// Execute executes the request
//  @return PaymentPublishUserPostResponse
func (a *PaymentAPIService) PaymentPublishUserPostExecute(r ApiPaymentPublishUserPostRequest) (*PaymentPublishUserPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentPublishUserPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentAPIService.PaymentPublishUserPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/experimental/open-platform/post/{post_token}/publish"
	localVarPath = strings.Replace(localVarPath, "{"+"post_token"+"}", url.PathEscape(parameterValueToString(r.postToken, "postToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.paymentPublishUserPostBody == nil {
		return localVarReturnValue, nil, reportError("paymentPublishUserPostBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.paymentPublishUserPostBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPaymentRenewPostRequest struct {
	ctx context.Context
	ApiService *PaymentAPIService
	postToken string
	paymentRenewPostBody *PaymentRenewPostBody
}

func (r ApiPaymentRenewPostRequest) PaymentRenewPostBody(paymentRenewPostBody PaymentRenewPostBody) ApiPaymentRenewPostRequest {
	r.paymentRenewPostBody = &paymentRenewPostBody
	return r
}

func (r ApiPaymentRenewPostRequest) Execute() (*PaymentRenewPostResponse, *http.Response, error) {
	return r.ApiService.PaymentRenewPostExecute(r)
}

/*
PaymentRenewPost تمدید آگهی

این API امکان تمدید آگهی را فراهم می‌کند که دوره نمایش آن در دیوار را افزایش می‌دهد. هزینه از موجودی اپلیکیشن شما کسر می‌شود.

**نکات مهم**:
- این قابلیت فقط برای اپلیکیشن‌های تایید شده در دسترس است
- قبل از تمدید، از `GetPostPricing` برای بررسی هزینه استفاده کنید
- یک `id` منحصر به فرد (UUID v4) برای جلوگیری از تکرار ارسال کنید
- آگهی باید در وضعیت PUBLISHED و واجد شرایط تمدید باشد
- از کافی بودن موجودی اپلیکیشن خود اطمینان حاصل کنید
- هزینه‌ها بر اساس دسته‌بندی و شهر آگهی متفاوت است
- تمدید، نمایش آگهی را افزایش داده و عمر آن را بازنشانی می‌کند

#### دسترسی‌ها:

##### مجوزهای API Key مورد نیاز:

- `POST_RENEW`

##### OAuth اسکوپ موردنیاز:

- `PAYMENT_ALL_POSTS_RENEW`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param postToken
 @return ApiPaymentRenewPostRequest
*/
func (a *PaymentAPIService) PaymentRenewPost(ctx context.Context, postToken string) ApiPaymentRenewPostRequest {
	return ApiPaymentRenewPostRequest{
		ApiService: a,
		ctx: ctx,
		postToken: postToken,
	}
}

// Execute executes the request
//  @return PaymentRenewPostResponse
func (a *PaymentAPIService) PaymentRenewPostExecute(r ApiPaymentRenewPostRequest) (*PaymentRenewPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentRenewPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentAPIService.PaymentRenewPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/experimental/open-platform/post/{post_token}/renew"
	localVarPath = strings.Replace(localVarPath, "{"+"post_token"+"}", url.PathEscape(parameterValueToString(r.postToken, "postToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.paymentRenewPostBody == nil {
		return localVarReturnValue, nil, reportError("paymentRenewPostBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.paymentRenewPostBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPaymentReorderPostRequest struct {
	ctx context.Context
	ApiService *PaymentAPIService
	postToken string
	paymentReorderPostBody *PaymentReorderPostBody
}

func (r ApiPaymentReorderPostRequest) PaymentReorderPostBody(paymentReorderPostBody PaymentReorderPostBody) ApiPaymentReorderPostRequest {
	r.paymentReorderPostBody = &paymentReorderPostBody
	return r
}

func (r ApiPaymentReorderPostRequest) Execute() (*PaymentReorderPostResponse, *http.Response, error) {
	return r.ApiService.PaymentReorderPostExecute(r)
}

/*
PaymentReorderPost نردبان آگهی

این API امکان نردبان کردن آگهی به بالای لیست را فراهم می‌کند. هزینه از موجودی اپلیکیشن شما کسر می‌شود.

**نکات مهم**:
- این قابلیت فقط برای اپلیکیشن‌های تایید شده در دسترس است
- قبل از نردبان، از `GetPostPricing` برای بررسی هزینه استفاده کنید
- یک `id` منحصر به فرد (UUID v4) برای جلوگیری از تکرار ارسال کنید
- آگهی باید در وضعیت PUBLISHED باشد
- از کافی بودن موجودی اپلیکیشن خود اطمینان حاصل کنید
- هزینه‌ها بر اساس دسته‌بندی و شهر آگهی متفاوت است

#### دسترسی‌ها:

##### مجوزهای API Key مورد نیاز:

- `POST_REORDER`

##### OAuth اسکوپ موردنیاز:

- `PAYMENT_ALL_POSTS_REORDER`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param postToken
 @return ApiPaymentReorderPostRequest
*/
func (a *PaymentAPIService) PaymentReorderPost(ctx context.Context, postToken string) ApiPaymentReorderPostRequest {
	return ApiPaymentReorderPostRequest{
		ApiService: a,
		ctx: ctx,
		postToken: postToken,
	}
}

// Execute executes the request
//  @return PaymentReorderPostResponse
func (a *PaymentAPIService) PaymentReorderPostExecute(r ApiPaymentReorderPostRequest) (*PaymentReorderPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentReorderPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentAPIService.PaymentReorderPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/experimental/open-platform/post/{post_token}/reorder"
	localVarPath = strings.Replace(localVarPath, "{"+"post_token"+"}", url.PathEscape(parameterValueToString(r.postToken, "postToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.paymentReorderPostBody == nil {
		return localVarReturnValue, nil, reportError("paymentReorderPostBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.paymentReorderPostBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPaymentRetrieveWalletTransactionRequest struct {
	ctx context.Context
	ApiService *PaymentAPIService
	token string
}

func (r ApiPaymentRetrieveWalletTransactionRequest) Execute() (*PaymentRetrieveWalletTransactionResponse, *http.Response, error) {
	return r.ApiService.PaymentRetrieveWalletTransactionExecute(r)
}

/*
PaymentRetrieveWalletTransaction دریافت تراکنش کیف پول

این API امکان دریافت وضعیت فعلی و جزئیات تراکنش پرداخت کیف پول را فراهم می‌کند. برای تایید تکمیل پرداخت قبل از commit کردن تراکنش استفاده کنید.

**نکات مهم**:
- این قابلیت آزمایشی است و فقط برای اپلیکیشن‌های تایید شده در دسترس است
- وضعیت‌های تراکنش: UNKNOWN، CREATED، EXPIRED، PAID، COMMITTED

#### دسترسی‌ها:

##### مجوزهای API Key مورد نیاز:

- `WALLET_PAYMENT`

##### OAuth اسکوپ موردنیاز:

- `CREATE_WALLET_PAYMENT`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token توکن تراکنشی که می‌خواهید دریافت کنید
 @return ApiPaymentRetrieveWalletTransactionRequest
*/
func (a *PaymentAPIService) PaymentRetrieveWalletTransaction(ctx context.Context, token string) ApiPaymentRetrieveWalletTransactionRequest {
	return ApiPaymentRetrieveWalletTransactionRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return PaymentRetrieveWalletTransactionResponse
func (a *PaymentAPIService) PaymentRetrieveWalletTransactionExecute(r ApiPaymentRetrieveWalletTransactionRequest) (*PaymentRetrieveWalletTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentRetrieveWalletTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentAPIService.PaymentRetrieveWalletTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/experimental/open-platform/wallet/payments/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPaymentSubmitUserPaymentRequest struct {
	ctx context.Context
	ApiService *PaymentAPIService
	paymentSubmitUserPaymentRequest *PaymentSubmitUserPaymentRequest
}

func (r ApiPaymentSubmitUserPaymentRequest) PaymentSubmitUserPaymentRequest(paymentSubmitUserPaymentRequest PaymentSubmitUserPaymentRequest) ApiPaymentSubmitUserPaymentRequest {
	r.paymentSubmitUserPaymentRequest = &paymentSubmitUserPaymentRequest
	return r
}

func (r ApiPaymentSubmitUserPaymentRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PaymentSubmitUserPaymentExecute(r)
}

/*
PaymentSubmitUserPayment ثبت رکورد پرداخت کاربر

این API امکان گزارش پرداخت انجام شده توسط کاربر به سرویس شما را فراهم می‌کند. از این برای اطلاع‌رسانی دیوار درباره تراکنش‌هایی که کاربران از طریق پلتفرم شما پرداخت می‌کنند استفاده کنید.

**نکات مهم**:
- باید پرداخت‌ها را در بازه زمانی توافق شده گزارش دهید
- `reference_id` باید برای هر تراکنش منحصر به فرد باشد (برای تسویه حساب استفاده می‌شود)
- شناسه خدماتی که کاربر برای آنها پرداخت کرده را لیست کنید (مثلاً 'banner', 'title_refinement')
- این داده‌ها برای تقسیم درآمد و گزارش مالی استفاده می‌شوند


#### دسترسی‌ها:

##### مجوزهای API Key مورد نیاز:

- `SUBMIT_USER_PAYMENT`

##### OAuth اسکوپ موردنیاز:

- `SUBMIT_USER_PAYMENT`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPaymentSubmitUserPaymentRequest
*/
func (a *PaymentAPIService) PaymentSubmitUserPayment(ctx context.Context) ApiPaymentSubmitUserPaymentRequest {
	return ApiPaymentSubmitUserPaymentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PaymentAPIService) PaymentSubmitUserPaymentExecute(r ApiPaymentSubmitUserPaymentRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentAPIService.PaymentSubmitUserPayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/open-platform/user-payments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.paymentSubmitUserPaymentRequest == nil {
		return localVarReturnValue, nil, reportError("paymentSubmitUserPaymentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.paymentSubmitUserPaymentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
