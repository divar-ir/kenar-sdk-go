/*
API کنار

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package kenarapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// PaymentAPIService PaymentAPI service
type PaymentAPIService service

type ApiPaymentCommitWalletTransactionRequest struct {
	ctx context.Context
	ApiService *PaymentAPIService
	paymentCommitWalletTransactionRequest *PaymentCommitWalletTransactionRequest
}

func (r ApiPaymentCommitWalletTransactionRequest) PaymentCommitWalletTransactionRequest(paymentCommitWalletTransactionRequest PaymentCommitWalletTransactionRequest) ApiPaymentCommitWalletTransactionRequest {
	r.paymentCommitWalletTransactionRequest = &paymentCommitWalletTransactionRequest
	return r
}

func (r ApiPaymentCommitWalletTransactionRequest) Execute() (*PaymentCommitWalletTransactionResponse, *http.Response, error) {
	return r.ApiService.PaymentCommitWalletTransactionExecute(r)
}

/*
PaymentCommitWalletTransaction تایید تراکنش کیف پول

This API allows you to finalize a wallet payment transaction after the user has successfully paid. Call this endpoint to mark the transaction as complete and trigger your business logic.

**OAuth Scopes**:
- `CREATE_WALLET_PAYMENT` - Allows creating wallet payment transactions on behalf of the user

**Important Notes**:
- This feature is experimental and limited to approved apps only
- Only commit transactions that are in PAID status

مجوزهای مورد نیاز: WALLET_PAYMENT. نیاز به دامنه‌های OAuth: CREATE_WALLET_PAYMENT.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPaymentCommitWalletTransactionRequest
*/
func (a *PaymentAPIService) PaymentCommitWalletTransaction(ctx context.Context) ApiPaymentCommitWalletTransactionRequest {
	return ApiPaymentCommitWalletTransactionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaymentCommitWalletTransactionResponse
func (a *PaymentAPIService) PaymentCommitWalletTransactionExecute(r ApiPaymentCommitWalletTransactionRequest) (*PaymentCommitWalletTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentCommitWalletTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentAPIService.PaymentCommitWalletTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/experimental/open-platform/wallet/payments/commit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.paymentCommitWalletTransactionRequest == nil {
		return localVarReturnValue, nil, reportError("paymentCommitWalletTransactionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.paymentCommitWalletTransactionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPaymentCreateWalletPaymentRequest struct {
	ctx context.Context
	ApiService *PaymentAPIService
	paymentCreateWalletPaymentRequest *PaymentCreateWalletPaymentRequest
}

func (r ApiPaymentCreateWalletPaymentRequest) PaymentCreateWalletPaymentRequest(paymentCreateWalletPaymentRequest PaymentCreateWalletPaymentRequest) ApiPaymentCreateWalletPaymentRequest {
	r.paymentCreateWalletPaymentRequest = &paymentCreateWalletPaymentRequest
	return r
}

func (r ApiPaymentCreateWalletPaymentRequest) Execute() (*PaymentCreateWalletPaymentResponse, *http.Response, error) {
	return r.ApiService.PaymentCreateWalletPaymentExecute(r)
}

/*
PaymentCreateWalletPayment ایجاد پرداخت کیف پول

This API allows you to initiate a payment transaction from a user's Divar wallet. The user will be redirected to complete the payment, and you can track the transaction status.

**OAuth Scopes**:
- `CREATE_WALLET_PAYMENT` - Allows creating wallet payment transactions on behalf of the user

**Important Notes**:
- This feature is experimental and limited to approved apps only
- User will be redirected to the payment URL to complete the transaction
- After payment, user is redirected to your specified `redirect_url`
- Use `RetrieveWalletTransaction` to check payment status
- Use `CommitWalletTransaction` to finalize the transaction after successful payment


مجوزهای مورد نیاز: WALLET_PAYMENT. نیاز به دامنه‌های OAuth: CREATE_WALLET_PAYMENT.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPaymentCreateWalletPaymentRequest
*/
func (a *PaymentAPIService) PaymentCreateWalletPayment(ctx context.Context) ApiPaymentCreateWalletPaymentRequest {
	return ApiPaymentCreateWalletPaymentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaymentCreateWalletPaymentResponse
func (a *PaymentAPIService) PaymentCreateWalletPaymentExecute(r ApiPaymentCreateWalletPaymentRequest) (*PaymentCreateWalletPaymentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentCreateWalletPaymentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentAPIService.PaymentCreateWalletPayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/experimental/open-platform/wallet/payments/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.paymentCreateWalletPaymentRequest == nil {
		return localVarReturnValue, nil, reportError("paymentCreateWalletPaymentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.paymentCreateWalletPaymentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPaymentGetBalanceRequest struct {
	ctx context.Context
	ApiService *PaymentAPIService
}

func (r ApiPaymentGetBalanceRequest) Execute() (*PaymentGetBalanceResponse, *http.Response, error) {
	return r.ApiService.PaymentGetBalanceExecute(r)
}

/*
PaymentGetBalance دریافت موجودی اپلیکیشن

This API allows you to retrieve your app's current balance in rials. Use this to monitor your account balance before performing paid operations.

**Note**: This API does not require user authorization.

**Important Notes**:
- This feature is limited to approved apps only
- Balance is returned in Iranian Rials

مجوزهای مورد نیاز: BALANCE_RETRIEVE.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPaymentGetBalanceRequest
*/
func (a *PaymentAPIService) PaymentGetBalance(ctx context.Context) ApiPaymentGetBalanceRequest {
	return ApiPaymentGetBalanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaymentGetBalanceResponse
func (a *PaymentAPIService) PaymentGetBalanceExecute(r ApiPaymentGetBalanceRequest) (*PaymentGetBalanceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentGetBalanceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentAPIService.PaymentGetBalance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/experimental/open-platform/balance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPaymentGetPostPricingRequest struct {
	ctx context.Context
	ApiService *PaymentAPIService
	postToken string
}

func (r ApiPaymentGetPostPricingRequest) Execute() (*PaymentGetPostPricingResponse, *http.Response, error) {
	return r.ApiService.PaymentGetPostPricingExecute(r)
}

/*
PaymentGetPostPricing Get post service pricing

This API allows you to retrieve pricing information for post-related services. Use this endpoint to check costs before performing paid operations like reordering, renewing, or submitting posts.

**OAuth Scopes**:
- `PAYMENT_ALL_POSTS_PRICING_READ` - Allows reading pricing for posts on behalf of the user

**Important Notes**:
- Pricing is specific to your app and may differ from standard Divar pricing
- Prices may vary based on post category and city
- The `available` flag indicates whether the service can be applied to this post

مجوزهای مورد نیاز: POST_PRICING_RETRIEVE. نیاز به دامنه‌های OAuth: PAYMENT_ALL_POSTS_PRICING_READ.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param postToken شناسه منحصر به فرد 8-9 کاراکتری برای آگهی
 @return ApiPaymentGetPostPricingRequest
*/
func (a *PaymentAPIService) PaymentGetPostPricing(ctx context.Context, postToken string) ApiPaymentGetPostPricingRequest {
	return ApiPaymentGetPostPricingRequest{
		ApiService: a,
		ctx: ctx,
		postToken: postToken,
	}
}

// Execute executes the request
//  @return PaymentGetPostPricingResponse
func (a *PaymentAPIService) PaymentGetPostPricingExecute(r ApiPaymentGetPostPricingRequest) (*PaymentGetPostPricingResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentGetPostPricingResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentAPIService.PaymentGetPostPricing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/open-platform/post/{post_token}/pricing"
	localVarPath = strings.Replace(localVarPath, "{"+"post_token"+"}", url.PathEscape(parameterValueToString(r.postToken, "postToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPaymentGetTransactionRequest struct {
	ctx context.Context
	ApiService *PaymentAPIService
	id string
}

func (r ApiPaymentGetTransactionRequest) Execute() (*PaymentGetTransactionResponse, *http.Response, error) {
	return r.ApiService.PaymentGetTransactionExecute(r)
}

/*
PaymentGetTransaction دریافت جزئیات تراکنش

This API allows you to retrieve detailed information about a specific transaction using its ID. Use this to track transaction status, costs, and metadata.

**Note**: This API does not require user authorization.

**Important Notes**:
- This feature is limited to approved apps only
- Transaction ID is the UUID you provided when creating the transaction
- Transaction states: PENDING, COMPLETED, FAILED, REFUNDED
- Transaction types: REORDER, SUBMIT, RENEW
- Use this to verify transaction completion after paid operations

مجوزهای مورد نیاز: TRANSACTION_RETRIEVE.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id شناسه منحصر به فرد برای تراکنش، همان id در درخواست
 @return ApiPaymentGetTransactionRequest
*/
func (a *PaymentAPIService) PaymentGetTransaction(ctx context.Context, id string) ApiPaymentGetTransactionRequest {
	return ApiPaymentGetTransactionRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaymentGetTransactionResponse
func (a *PaymentAPIService) PaymentGetTransactionExecute(r ApiPaymentGetTransactionRequest) (*PaymentGetTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentGetTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentAPIService.PaymentGetTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/experimental/open-platform/transactions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPaymentListTransactionsRequest struct {
	ctx context.Context
	ApiService *PaymentAPIService
	pageSize *int32
	pageToken *string
}

// تعداد تراکنش‌ها برای برگرداندن در هر صفحه
func (r ApiPaymentListTransactionsRequest) PageSize(pageSize int32) ApiPaymentListTransactionsRequest {
	r.pageSize = &pageSize
	return r
}

// توکن برای صفحه بعدی نتایج
func (r ApiPaymentListTransactionsRequest) PageToken(pageToken string) ApiPaymentListTransactionsRequest {
	r.pageToken = &pageToken
	return r
}

func (r ApiPaymentListTransactionsRequest) Execute() (*PaymentListTransactionsResponse, *http.Response, error) {
	return r.ApiService.PaymentListTransactionsExecute(r)
}

/*
PaymentListTransactions لیست تراکنش‌ها

This API allows you to retrieve a paginated list of your app's transactions. Use this for transaction history, auditing, and reconciliation.

**Note**: This API does not require user authorization.

**Important Notes**:
- This feature is limited to approved apps only
- Results are paginated - use `page_size` to control items per page
- Use `page_token` from the response to fetch the next page
- Transactions are ordered by creation time (newest first)

مجوزهای مورد نیاز: TRANSACTION_LIST.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPaymentListTransactionsRequest
*/
func (a *PaymentAPIService) PaymentListTransactions(ctx context.Context) ApiPaymentListTransactionsRequest {
	return ApiPaymentListTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaymentListTransactionsResponse
func (a *PaymentAPIService) PaymentListTransactionsExecute(r ApiPaymentListTransactionsRequest) (*PaymentListTransactionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentListTransactionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentAPIService.PaymentListTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/experimental/open-platform/transactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.pageToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_token", r.pageToken, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPaymentPublishUserPostRequest struct {
	ctx context.Context
	ApiService *PaymentAPIService
	postToken string
	paymentPublishUserPostBody *PaymentPublishUserPostBody
}

func (r ApiPaymentPublishUserPostRequest) PaymentPublishUserPostBody(paymentPublishUserPostBody PaymentPublishUserPostBody) ApiPaymentPublishUserPostRequest {
	r.paymentPublishUserPostBody = &paymentPublishUserPostBody
	return r
}

func (r ApiPaymentPublishUserPostRequest) Execute() (*PaymentPublishUserPostResponse, *http.Response, error) {
	return r.ApiService.PaymentPublishUserPostExecute(r)
}

/*
PaymentPublishUserPost Publish user post (provider pays)

This API allows you to pay for publishing a user-submitted post on behalf of your app. The cost is deducted from your app's balance, and the post will be published.

**OAuth Scopes** (required):
- `SUBMIT_USER_PAYMENT` - Allows reporting user payments to Divar

**Important Notes**:
- The post must be created using the `SubmitUserPost` API first
- Provide a unique `id` (UUID v4) for idempotency
- The post must be in a state that requires payment (WAITING_FOR_PAYMENT)
- Ensure your app has sufficient balance
- Costs vary by post category and city

مجوزهای مورد نیاز: PUBLISH_USER_POST. نیاز به دامنه‌های OAuth: SUBMIT_USER_PAYMENT.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param postToken توکن آگهی دریافت شده از RPC SubmitUserPost. شناسه منحصر به فرد 8-9 کاراکتری برای آگهی ثبت شده توسط کاربر.
 @return ApiPaymentPublishUserPostRequest
*/
func (a *PaymentAPIService) PaymentPublishUserPost(ctx context.Context, postToken string) ApiPaymentPublishUserPostRequest {
	return ApiPaymentPublishUserPostRequest{
		ApiService: a,
		ctx: ctx,
		postToken: postToken,
	}
}

// Execute executes the request
//  @return PaymentPublishUserPostResponse
func (a *PaymentAPIService) PaymentPublishUserPostExecute(r ApiPaymentPublishUserPostRequest) (*PaymentPublishUserPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentPublishUserPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentAPIService.PaymentPublishUserPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/experimental/open-platform/post/{post_token}/publish"
	localVarPath = strings.Replace(localVarPath, "{"+"post_token"+"}", url.PathEscape(parameterValueToString(r.postToken, "postToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.paymentPublishUserPostBody == nil {
		return localVarReturnValue, nil, reportError("paymentPublishUserPostBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.paymentPublishUserPostBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPaymentRenewPostRequest struct {
	ctx context.Context
	ApiService *PaymentAPIService
	postToken string
	paymentRenewPostBody *PaymentRenewPostBody
}

func (r ApiPaymentRenewPostRequest) PaymentRenewPostBody(paymentRenewPostBody PaymentRenewPostBody) ApiPaymentRenewPostRequest {
	r.paymentRenewPostBody = &paymentRenewPostBody
	return r
}

func (r ApiPaymentRenewPostRequest) Execute() (*PaymentRenewPostResponse, *http.Response, error) {
	return r.ApiService.PaymentRenewPostExecute(r)
}

/*
PaymentRenewPost تمدید آگهی

This API allows you to renew a post, which extends its visibility period on Divar. The cost is deducted from your app's balance.

**OAuth Scopes**:
- `PAYMENT_ALL_POSTS_RENEW` - Allows renewing posts on behalf of the user

**Important Notes**:
- This feature is limited to approved apps only
- Use `GetPostPricing` to check the cost before renewing
- Provide a unique `id` (UUID v4) for idempotency
- The post must be in PUBLISHED state and eligible for renewal
- Ensure your app has sufficient balance
- Costs vary by post category and city
- Renewal extends the post's visibility and resets its age

مجوزهای مورد نیاز: POST_RENEW. نیاز به دامنه‌های OAuth: PAYMENT_ALL_POSTS_RENEW.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param postToken
 @return ApiPaymentRenewPostRequest
*/
func (a *PaymentAPIService) PaymentRenewPost(ctx context.Context, postToken string) ApiPaymentRenewPostRequest {
	return ApiPaymentRenewPostRequest{
		ApiService: a,
		ctx: ctx,
		postToken: postToken,
	}
}

// Execute executes the request
//  @return PaymentRenewPostResponse
func (a *PaymentAPIService) PaymentRenewPostExecute(r ApiPaymentRenewPostRequest) (*PaymentRenewPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentRenewPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentAPIService.PaymentRenewPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/experimental/open-platform/post/{post_token}/renew"
	localVarPath = strings.Replace(localVarPath, "{"+"post_token"+"}", url.PathEscape(parameterValueToString(r.postToken, "postToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.paymentRenewPostBody == nil {
		return localVarReturnValue, nil, reportError("paymentRenewPostBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.paymentRenewPostBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPaymentReorderPostRequest struct {
	ctx context.Context
	ApiService *PaymentAPIService
	postToken string
	paymentReorderPostBody *PaymentReorderPostBody
}

func (r ApiPaymentReorderPostRequest) PaymentReorderPostBody(paymentReorderPostBody PaymentReorderPostBody) ApiPaymentReorderPostRequest {
	r.paymentReorderPostBody = &paymentReorderPostBody
	return r
}

func (r ApiPaymentReorderPostRequest) Execute() (*PaymentReorderPostResponse, *http.Response, error) {
	return r.ApiService.PaymentReorderPostExecute(r)
}

/*
PaymentReorderPost نردبان آگهی

This API allows you to reorder (bump) a post to the top of the listing. The cost is deducted from your app's balance.

**OAuth Scopes**:
- `PAYMENT_ALL_POSTS_REORDER` - Allows reordering posts on behalf of the user

**Important Notes**:
- This feature is limited to approved apps only
- Use `GetPostPricing` to check the cost before reordering
- Provide a unique `id` (UUID v4) for idempotency
- The post must be in PUBLISHED state
- Ensure your app has sufficient balance
- Costs vary by post category and city

مجوزهای مورد نیاز: POST_REORDER. نیاز به دامنه‌های OAuth: PAYMENT_ALL_POSTS_REORDER.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param postToken
 @return ApiPaymentReorderPostRequest
*/
func (a *PaymentAPIService) PaymentReorderPost(ctx context.Context, postToken string) ApiPaymentReorderPostRequest {
	return ApiPaymentReorderPostRequest{
		ApiService: a,
		ctx: ctx,
		postToken: postToken,
	}
}

// Execute executes the request
//  @return PaymentReorderPostResponse
func (a *PaymentAPIService) PaymentReorderPostExecute(r ApiPaymentReorderPostRequest) (*PaymentReorderPostResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentReorderPostResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentAPIService.PaymentReorderPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/experimental/open-platform/post/{post_token}/reorder"
	localVarPath = strings.Replace(localVarPath, "{"+"post_token"+"}", url.PathEscape(parameterValueToString(r.postToken, "postToken")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.paymentReorderPostBody == nil {
		return localVarReturnValue, nil, reportError("paymentReorderPostBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.paymentReorderPostBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPaymentRetrieveWalletTransactionRequest struct {
	ctx context.Context
	ApiService *PaymentAPIService
	token string
}

func (r ApiPaymentRetrieveWalletTransactionRequest) Execute() (*PaymentRetrieveWalletTransactionResponse, *http.Response, error) {
	return r.ApiService.PaymentRetrieveWalletTransactionExecute(r)
}

/*
PaymentRetrieveWalletTransaction بازیابی تراکنش کیف پول

This API allows you to retrieve the current status and details of a wallet payment transaction. Use this to verify payment completion before committing the transaction.

**OAuth Scopes**:
- `CREATE_WALLET_PAYMENT` - Allows creating wallet payment transactions on behalf of the user

**Important Notes**:
- This feature is experimental and limited to approved apps only
- Transaction statuses: UNKNOWN, CREATED, EXPIRED, PAID, COMMITTED

مجوزهای مورد نیاز: WALLET_PAYMENT. نیاز به دامنه‌های OAuth: CREATE_WALLET_PAYMENT.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param token توکن تراکنشی که می‌خواهید بازیابی کنید
 @return ApiPaymentRetrieveWalletTransactionRequest
*/
func (a *PaymentAPIService) PaymentRetrieveWalletTransaction(ctx context.Context, token string) ApiPaymentRetrieveWalletTransactionRequest {
	return ApiPaymentRetrieveWalletTransactionRequest{
		ApiService: a,
		ctx: ctx,
		token: token,
	}
}

// Execute executes the request
//  @return PaymentRetrieveWalletTransactionResponse
func (a *PaymentAPIService) PaymentRetrieveWalletTransactionExecute(r ApiPaymentRetrieveWalletTransactionRequest) (*PaymentRetrieveWalletTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentRetrieveWalletTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentAPIService.PaymentRetrieveWalletTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/experimental/open-platform/wallet/payments/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPaymentSubmitUserPaymentRequest struct {
	ctx context.Context
	ApiService *PaymentAPIService
	paymentSubmitUserPaymentRequest *PaymentSubmitUserPaymentRequest
}

func (r ApiPaymentSubmitUserPaymentRequest) PaymentSubmitUserPaymentRequest(paymentSubmitUserPaymentRequest PaymentSubmitUserPaymentRequest) ApiPaymentSubmitUserPaymentRequest {
	r.paymentSubmitUserPaymentRequest = &paymentSubmitUserPaymentRequest
	return r
}

func (r ApiPaymentSubmitUserPaymentRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PaymentSubmitUserPaymentExecute(r)
}

/*
PaymentSubmitUserPayment Submit user payment record

This API allows you to report a payment made by a user to your service. Use this to inform Divar about transactions where users pay for services through your platform.

**OAuth Scopes** (required):
- `SUBMIT_USER_PAYMENT` - Allows reporting user payments to Divar

**Important Notes**:
- You must report payments within the agreed timeframe
- The `reference_id` must be unique for each transaction (used for reconciliation)
- List specific service slugs the user paid for (e.g., 'banner', 'title_refinement')
- This data is used for revenue sharing and financial reporting


مجوزهای مورد نیاز: SUBMIT_USER_PAYMENT. نیاز به دامنه‌های OAuth: SUBMIT_USER_PAYMENT.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPaymentSubmitUserPaymentRequest
*/
func (a *PaymentAPIService) PaymentSubmitUserPayment(ctx context.Context) ApiPaymentSubmitUserPaymentRequest {
	return ApiPaymentSubmitUserPaymentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PaymentAPIService) PaymentSubmitUserPaymentExecute(r ApiPaymentSubmitUserPaymentRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentAPIService.PaymentSubmitUserPayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/open-platform/user-payments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.paymentSubmitUserPaymentRequest == nil {
		return localVarReturnValue, nil, reportError("paymentSubmitUserPaymentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.paymentSubmitUserPaymentRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
